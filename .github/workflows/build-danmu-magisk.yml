name: Build Danmu API Magisk Modules

on:
  workflow_dispatch:
    inputs:
      repo_source:
        description: "选择 danmu_api 源仓库"
        type: choice
        options:
          - huangxd-/danmu_api
          - lilixu3/danmu_api
          - custom
        default: huangxd-/danmu_api
        required: true

      custom_repo:
        description: "自定义仓库（owner/repo）"
        type: string
        required: false
        default: ""

      repo_ref:
        description: "分支 / Tag / Commit"
        type: string
        required: true
        default: main

      build_variant:
        description: "构建版本"
        type: choice
        options:
          - both
          - no_node
          - node
        default: both
        required: true

      module_version:
        description: "模块版本号"
        type: string
        required: true
        default: "1.1.2"

      publish_release:
        description: "是否上传到 GitHub Release"
        type: boolean
        required: true
        default: false

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    env:
      TEMPLATE_NO_NODE: danmu_api_server.zip
      TEMPLATE_NODE: danmu_api_server_node.zip
      UPSTREAM_SUBDIR: danmu_api

    steps:
      - name: Checkout current repo
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y zip unzip rsync curl jq binutils zstd

      - name: Fetch upstream danmu_api
        run: |
          REPO="${{ inputs.repo_source }}"
          [ "$REPO" = "custom" ] && REPO="${{ inputs.custom_repo }}"
          echo ">>> Cloning $REPO..."
          git clone --depth 1 --branch "${{ inputs.repo_ref }}" "https://github.com/${REPO}.git" upstream

      - name: Build modules
        run: |
          set -euo pipefail
          VERSION="${{ inputs.module_version }}"
          VERSION_CODE="$(echo "$VERSION" | tr -cd '0-9' | head -c 8)"
          [ -z "$VERSION_CODE" ] && VERSION_CODE=1
          
          mkdir -p build/tmp build/out

          # =========================================================
          # 函数：下载并提取 Termux Node.js (动态路径修复版)
          # =========================================================
          fetch_termux_node() {
            local root="$1"
            local repo_url="https://packages.termux.dev/apt/termux-main"
            local arch="aarch64"
            local work_dir="node_work"
            
            echo "---------------------------------------------------"
            echo ">>> [Node构建] 开始处理 Termux Node环境..."
            
            rm -rf "$work_dir"
            mkdir -p "$work_dir/extracted"
            cd "$work_dir"
            
            echo ">>> [Node构建] 下载软件包索引..."
            curl -sL "${repo_url}/dists/stable/main/binary-${arch}/Packages" > Packages

            # 关键依赖：libandroid-support 是必须的，否则报错
            local pkgs="nodejs libandroid-support libc++ openssl zlib"
            
            for pkg in $pkgs; do
                echo ">>> [Node构建] 处理依赖包: $pkg"
                local deb_rel_path=$(grep -A 20 "Package: ${pkg}$" Packages | grep "Filename:" | awk '{print $2}' | head -n 1)
                
                if [ -z "$deb_rel_path" ]; then
                    echo "!!! 错误: 无法在源中找到 $pkg"
                    exit 1
                fi

                # 下载
                curl -L -f --retry 3 "${repo_url}/${deb_rel_path}" -o "${pkg}.deb"
                
                # 解压 ar
                ar x "${pkg}.deb"
                
                # 解压 data.tar (兼容 zst 和 xz)
                if [ -f data.tar.zst ]; then
                    tar --zstd -xf data.tar.zst -C extracted/
                elif [ -f data.tar.xz ]; then
                    tar -xf data.tar.xz -C extracted/
                else
                    echo "!!! 错误: 未知压缩格式"
                    ls -l
                    exit 1
                fi
                
                rm -f control.tar.* data.tar.* debian-binary "${pkg}.deb"
            done

            # --- 核心修复：动态查找文件位置 ---
            echo ">>> [Node构建] 定位二进制文件..."
            
            # 无论解压路径多深，直接找 bin/node
            NODE_BIN_PATH=$(find extracted -type f -path "*/bin/node" | head -n 1)

            if [ -z "$NODE_BIN_PATH" ]; then
                echo "!!! 错误: 未找到 node 二进制文件"
                echo "目录结构调试:"
                find extracted -maxdepth 4
                exit 1
            fi
            
            echo "    Found Node at: $NODE_BIN_PATH"

            # 反推 lib 目录 (bin 的同级目录 ../lib)
            TERMUX_USR_DIR=$(dirname "$(dirname "$NODE_BIN_PATH")")
            TERMUX_LIB_DIR="$TERMUX_USR_DIR/lib"
            
            if [ ! -d "$TERMUX_LIB_DIR" ]; then
                echo "!!! 错误: 未找到对应的 lib 目录: $TERMUX_LIB_DIR"
                exit 1
            fi

            # --- 移动文件 ---
            echo ">>> [Node构建] 写入模块目录..."
            mkdir -p "$root/node/bin"
            mkdir -p "$root/node/lib"

            # 复制 node
            cp "$NODE_BIN_PATH" "$root/node/bin/"
            chmod 0755 "$root/node/bin/node"

            # 复制库文件 (使用 -a 保留软链接，这很重要！)
            cp -a "$TERMUX_LIB_DIR"/. "$root/node/lib/"

            # --- 验证 ---
            echo ">>> [Node构建] 验证结果:"
            echo "    Node Bin: $(ls -F "$root/node/bin/")"
            echo "    Lib Count: $(find "$root/node/lib" -type f | wc -l) (files)"

            # 清理工作区
            cd ..
            rm -rf "$work_dir"

            # --- 注入环境变量 ---
            if [ -f "$root/service.sh" ]; then
                echo ">>> [Node构建] 更新 service.sh..."
                sed -i '2i # --- Node Env ---\nMODDIR=${0%/*}\nexport PATH=$MODDIR/node/bin:$PATH\nexport LD_LIBRARY_PATH=$MODDIR/node/lib:$LD_LIBRARY_PATH\n# ----------------' "$root/service.sh"
            fi
            echo "---------------------------------------------------"
          }

          # =========================================================
          # 函数：打包 ZIP
          # =========================================================
          finalize_zip() {
            local root="$1"
            local out_name="$2"
            echo ">>> 打包: $out_name"
            find "$root" -type f -name "*.sh" -exec chmod 0755 {} \;
            (cd "$root" && zip -r "../../out/${out_name}" .)
          }

          # =========================================================
          # 流程 1: No-Node 版本
          # =========================================================
          if [[ "${{ inputs.build_variant }}" == "both" || "${{ inputs.build_variant }}" == "no_node" ]]; then
            echo ">>> [TASK] 构建 No-Node 版本..."
            unzip -q "${TEMPLATE_NO_NODE}" -d build/tmp/no_node
            
            # 动态查找模块根目录 (包含 module.prop 的目录)
            MODULE_ROOT=$(find build/tmp/no_node -name "module.prop" | head -n 1 | xargs dirname)
            
            # 确保目标目录存在
            mkdir -p "$MODULE_ROOT/app/danmu_api"
            
            # 同步文件
            rsync -a --delete "upstream/${UPSTREAM_SUBDIR}/" "$MODULE_ROOT/app/danmu_api/"
            
            # 修改版本号
            sed -i "s|^version=.*|version=${VERSION}|g" "$MODULE_ROOT/module.prop"
            sed -i "s|^versionCode=.*|versionCode=${VERSION_CODE}|g" "$MODULE_ROOT/module.prop"
            
            finalize_zip "$MODULE_ROOT" "danmu_api_server_${VERSION}.zip"
          fi

          # =========================================================
          # 流程 2: Node 版本
          # =========================================================
          if [[ "${{ inputs.build_variant }}" == "both" || "${{ inputs.build_variant }}" == "node" ]]; then
            echo ">>> [TASK] 构建 Node 完整版..."
            unzip -q "${TEMPLATE_NODE}" -d build/tmp/node
            
            MODULE_ROOT=$(find build/tmp/node -name "module.prop" | head -n 1 | xargs dirname)
            
            # 确保目标目录存在
            mkdir -p "$MODULE_ROOT/app/danmu_api"
            
            # 同步文件
            rsync -a --delete "upstream/${UPSTREAM_SUBDIR}/" "$MODULE_ROOT/app/danmu_api/"
            
            # 下载并注入 Node
            fetch_termux_node "$MODULE_ROOT"
            
            # 修改版本号
            sed -i "s|^version=.*|version=${VERSION}|g" "$MODULE_ROOT/module.prop"
            sed -i "s|^versionCode=.*|versionCode=${VERSION_CODE}|g" "$MODULE_ROOT/module.prop"
            
            finalize_zip "$MODULE_ROOT" "danmu_api_server_node_${VERSION}.zip"
          fi

      - name: Upload Flashable Modules
        uses: actions/upload-artifact@v4
        with:
          name: Danmu_API_v${{ inputs.module_version }}
          path: build/out/*.zip

      - name: Create Release
        if: ${{ inputs.publish_release }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ inputs.module_version }}
          files: build/out/*.zip
          generate_release_notes: true
