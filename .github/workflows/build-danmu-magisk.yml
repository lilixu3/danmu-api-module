name: Build Danmu API Magisk Modules

on:
  workflow_dispatch:
    inputs:
      repo_source:
        description: "选择 danmu_api 源仓库"
        type: choice
        options:
          - huangxd-/danmu_api
          - lilixu3/danmu_api
          - custom
        default: huangxd-/danmu_api
        required: true

      custom_repo:
        description: "自定义仓库（owner/repo）"
        type: string
        required: false
        default: ""

      repo_ref:
        description: "分支 / Tag / Commit"
        type: string
        required: true
        default: main

      build_variant:
        description: "构建版本"
        type: choice
        options:
          - both
          - no_node
          - node
        default: both
        required: true

      module_version:
        description: "模块版本号"
        type: string
        required: true
        default: "1.1.2"

      publish_release:
        description: "是否上传到 GitHub Release"
        type: boolean
        required: true
        default: false

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    env:
      TEMPLATE_NO_NODE: danmu_api_server.zip
      TEMPLATE_NODE: danmu_api_server_node.zip
      UPSTREAM_SUBDIR: danmu_api

    steps:
      - name: Checkout current repo
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y zip unzip rsync curl jq binutils zstd xz-utils dpkg

      - name: Fetch upstream danmu_api
        run: |
          set -euo pipefail
          REPO="${{ inputs.repo_source }}"
          [ "$REPO" = "custom" ] && REPO="${{ inputs.custom_repo }}"
          echo ">>> Cloning $REPO..."
          rm -rf upstream
          git clone --depth 1 "https://github.com/${REPO}.git" upstream
          cd upstream
          git fetch --depth 1 origin "${{ inputs.repo_ref }}" || true
          git checkout -q "${{ inputs.repo_ref }}" 2>/dev/null || git checkout -q FETCH_HEAD
          cd ..

      - name: Build modules
        shell: bash
        run: |
          set -euo pipefail
          VERSION="${{ inputs.module_version }}"
          VERSION_CODE="$(echo "$VERSION" | tr -cd '0-9' | head -c 8)"
          [ -z "$VERSION_CODE" ] && VERSION_CODE=1

          mkdir -p build/tmp build/out

          fetch_termux_node() {
            local root="$1"
            local arch="aarch64"

            local repo_base="https://packages.termux.dev/apt/termux-main"
            local index_xz="${repo_base}/dists/stable/main/binary-${arch}/Packages.xz"
            local index_plain="${repo_base}/dists/stable/main/binary-${arch}/Packages"

            local work_dir
            work_dir="$(mktemp -d)"
            local extracted="${work_dir}/extracted"
            mkdir -p "$extracted"

            echo "---------------------------------------------------"
            echo ">>> [Node构建] 开始拉取 Termux Node 运行时..."
            echo ">>> [Node构建] Repo: ${repo_base}"

            echo ">>> [Node构建] 下载 Packages 索引..."
            if curl -fL --retry 3 "$index_xz" -o "${work_dir}/Packages.xz"; then
              xz -dc "${work_dir}/Packages.xz" > "${work_dir}/Packages"
            else
              echo ">>> [Node构建] Packages.xz 不可用，回退 Packages..."
              curl -fL --retry 3 "$index_plain" -o "${work_dir}/Packages"
            fi
            local PKG_INDEX="${work_dir}/Packages"

            # ✅ 修复：不用正则匹配 Package: <name>（因为 libc++ 里的 + 会被 awk 当成正则元字符）
            pkg_filename() {
              local pkg="$1"
              awk -v pkg="$pkg" '
                BEGIN{RS="";FS="\n"}
                {
                  hit=0
                  for(i=1;i<=NF;i++){
                    if($i == "Package: " pkg){ hit=1; break }
                  }
                  if(hit){
                    for(i=1;i<=NF;i++){
                      if(index($i,"Filename: ")==1){
                        sub(/^Filename: /,"",$i);
                        print $i; exit
                      }
                    }
                  }
                }' "$PKG_INDEX"
            }

            # ✅ 修复：Depends 同样用字符串相等定位包块
            pkg_depends() {
              local pkg="$1"
              awk -v pkg="$pkg" '
                BEGIN{RS="";FS="\n"}
                {
                  hit=0
                  for(i=1;i<=NF;i++){
                    if($i == "Package: " pkg){ hit=1; break }
                  }
                  if(hit){
                    for(i=1;i<=NF;i++){
                      if(index($i,"Depends: ")==1){
                        dep=substr($i,10);
                        for(j=i+1;j<=NF && $j ~ /^ /; j++){
                          dep=dep " " substr($j,2);
                        }
                        print dep; exit
                      }
                    }
                  }
                }' "$PKG_INDEX"
            }

            parse_dep_groups() {
              local depstr="${1:-}"
              [ -z "$depstr" ] && return 0
              echo "$depstr" | tr ',' '\n' | while read -r grp; do
                grp="$(echo "$grp" | xargs)"
                [ -z "$grp" ] && continue
                grp="$(echo "$grp" | sed -E 's/\([^)]*\)//g')"
                grp="$(echo "$grp" | sed -E 's/:[a-z0-9_-]+//g')"
                grp="$(echo "$grp" | tr -s ' ' ' ' | xargs)"
                [ -n "$grp" ] && echo "$grp"
              done
            }

            resolve_group() {
              local grp="$1"
              local alt
              IFS='|' read -ra alts <<< "$grp"
              for alt in "${alts[@]}"; do
                alt="$(echo "$alt" | xargs)"
                [ -z "$alt" ] && continue

                local candidates=("$alt")
                if [ "$alt" = "libc++" ]; then
                  candidates=("libc++" "libc++-shared")
                elif [ "$alt" = "libc++-shared" ]; then
                  candidates=("libc++-shared" "libc++")
                fi

                local cand
                for cand in "${candidates[@]}"; do
                  local fname
                  fname="$(pkg_filename "$cand" || true)"
                  if [ -n "$fname" ]; then
                    echo "$cand"
                    return 0
                  fi
                done
              done
              return 1
            }

            download_and_extract() {
              local pkg="$1"
              local fname="$2"
              local url="${repo_base}/${fname}"
              echo ">>> [Node构建] 下载: $pkg"
              curl -fL --retry 3 "$url" -o "${work_dir}/${pkg}.deb"
              dpkg-deb -x "${work_dir}/${pkg}.deb" "$extracted"
              rm -f "${work_dir}/${pkg}.deb"
            }

            declare -A SEEN
            local queue=()
            local node_pkg="nodejs"
            queue+=("$node_pkg")

            while [ "${#queue[@]}" -gt 0 ]; do
              local pkg="${queue[0]}"
              queue=("${queue[@]:1}")

              [ -n "$pkg" ] || continue
              if [ "${SEEN[$pkg]+x}" = "x" ]; then
                continue
              fi
              SEEN["$pkg"]=1

              local fname
              fname="$(pkg_filename "$pkg" || true)"
              if [ -z "$fname" ]; then
                echo "!!! 错误: 在 Packages 索引中找不到包: $pkg"
                exit 1
              fi

              download_and_extract "$pkg" "$fname"

              local deps
              deps="$(pkg_depends "$pkg" || true)"
              while read -r grp; do
                [ -n "$grp" ] || continue
                local resolved
                if ! resolved="$(resolve_group "$grp")"; then
                  echo "!!! 错误: 依赖组无法解析（索引中都不存在）: $grp"
                  exit 1
                fi
                queue+=("$resolved")
              done < <(parse_dep_groups "$deps")
            done

            echo ">>> [Node构建] 定位 node 二进制..."
            local NODE_BIN_PATH
            NODE_BIN_PATH="$(find "$extracted" -type f -path "*/files/usr/bin/node" | head -n 1 || true)"
            if [ -z "$NODE_BIN_PATH" ]; then
              NODE_BIN_PATH="$(find "$extracted" -type f -path "*/usr/bin/node" | head -n 1 || true)"
            fi
            if [ -z "$NODE_BIN_PATH" ]; then
              echo "!!! 错误: 解压后未找到 node 可执行文件"
              find "$extracted" -maxdepth 8 -type d -name bin -print || true
              exit 1
            fi
            echo "    Found: $NODE_BIN_PATH"

            local PREFIX_DIR
            PREFIX_DIR="$(dirname "$(dirname "$NODE_BIN_PATH")")"
            local LIB_DIR="${PREFIX_DIR}/lib"
            if [ ! -d "$LIB_DIR" ]; then
              echo "!!! 错误: 未找到 lib 目录: $LIB_DIR"
              exit 1
            fi

            echo ">>> [Node构建] 写入模块目录: $root/node/{bin,lib}"
            mkdir -p "$root/node/bin" "$root/node/lib"

            cp -f "$NODE_BIN_PATH" "$root/node/bin/node"
            chmod 0755 "$root/node/bin/node"
            cp -a "$LIB_DIR"/. "$root/node/lib/"

            if [ ! -s "$root/node/bin/node" ]; then
              echo "!!! 错误: node 写入失败（文件为空或不存在）"
              exit 1
            fi

            local lib_items
            lib_items="$(find "$root/node/lib" -mindepth 1 \( -type f -o -type l -o -type d \) | wc -l | tr -d ' ')"
            if [ "${lib_items:-0}" -eq 0 ]; then
              echo "!!! 错误: node/lib 仍为空（依赖未写入）"
              exit 1
            fi

            echo ">>> [Node构建] 注入 service.sh 环境变量..."
            if [ -f "$root/service.sh" ]; then
              if ! grep -q "### NODE ENV BEGIN" "$root/service.sh"; then
                local tmp="${work_dir}/service.sh.tmp"
                {
                  head -n 1 "$root/service.sh"
                  printf '%s\n' \
                    '### NODE ENV BEGIN' \
                    'MODDIR=${0%/*}' \
                    'export PATH="$MODDIR/node/bin:$PATH"' \
                    'export LD_LIBRARY_PATH="$MODDIR/node/lib:${LD_LIBRARY_PATH:-}"' \
                    '### NODE ENV END'
                  tail -n +2 "$root/service.sh"
                } > "$tmp"
                mv "$tmp" "$root/service.sh"
                chmod 0755 "$root/service.sh"
              fi
            fi

            echo ">>> [Node构建] 验证通过:"
            echo "    node/lib items: $lib_items"
            echo "    libc++_shared.so exists? $( [ -e "$root/node/lib/libc++_shared.so" ] && echo yes || echo no )"
            echo "---------------------------------------------------"

            rm -rf "$work_dir"
          }

          finalize_zip() {
            local root="$1"
            local out_name="$2"
            echo ">>> 打包: $out_name"
            find "$root" -type f -name "*.sh" -exec chmod 0755 {} \;
            (cd "$root" && zip -r "../../out/${out_name}" .)
          }

          if [[ "${{ inputs.build_variant }}" == "both" || "${{ inputs.build_variant }}" == "no_node" ]]; then
            echo ">>> [TASK] 构建 No-Node 版本..."
            unzip -q "${TEMPLATE_NO_NODE}" -d build/tmp/no_node
            MODULE_ROOT=$(find build/tmp/no_node -name "module.prop" | head -n 1 | xargs dirname)

            mkdir -p "$MODULE_ROOT/app/danmu_api"
            rsync -a --delete "upstream/${UPSTREAM_SUBDIR}/" "$MODULE_ROOT/app/danmu_api/"

            sed -i "s|^version=.*|version=${VERSION}|g" "$MODULE_ROOT/module.prop"
            sed -i "s|^versionCode=.*|versionCode=${VERSION_CODE}|g" "$MODULE_ROOT/module.prop"

            finalize_zip "$MODULE_ROOT" "danmu_api_server_${VERSION}.zip"
          fi

          if [[ "${{ inputs.build_variant }}" == "both" || "${{ inputs.build_variant }}" == "node" ]]; then
            echo ">>> [TASK] 构建 Node 完整版..."
            unzip -q "${TEMPLATE_NODE}" -d build/tmp/node
            MODULE_ROOT=$(find build/tmp/node -name "module.prop" | head -n 1 | xargs dirname)

            mkdir -p "$MODULE_ROOT/app/danmu_api"
            rsync -a --delete "upstream/${UPSTREAM_SUBDIR}/" "$MODULE_ROOT/app/danmu_api/"

            fetch_termux_node "$MODULE_ROOT"

            sed -i "s|^version=.*|version=${VERSION}|g" "$MODULE_ROOT/module.prop"
            sed -i "s|^versionCode=.*|versionCode=${VERSION_CODE}|g" "$MODULE_ROOT/module.prop"

            finalize_zip "$MODULE_ROOT" "danmu_api_server_node_${VERSION}.zip"
          fi

      - name: Upload Flashable Modules
        uses: actions/upload-artifact@v4
        with:
          name: Danmu_API_v${{ inputs.module_version }}
          path: build/out/*.zip

      - name: Create Release
        if: ${{ inputs.publish_release }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ inputs.module_version }}
          files: build/out/*.zip
          generate_release_notes: true
