name: Build Danmu API Magisk Modules

on:
  workflow_dispatch:
    inputs:
      repo_source:
        description: "选择 danmu_api 源仓库"
        type: choice
        options:
          - huangxd-/danmu_api
          - lilixu3/danmu_api
          - custom
        default: huangxd-/danmu_api
        required: true

      custom_repo:
        description: "自定义仓库（owner/repo）"
        type: string
        required: false
        default: ""

      repo_ref:
        description: "分支 / Tag / Commit"
        type: string
        required: true
        default: main

      build_variant:
        description: "构建版本"
        type: choice
        options:
          - both
          - no_node
          - node
        default: both
        required: true

      module_version:
        description: "模块版本号"
        type: string
        required: true
        default: "1.1.2"

      publish_release:
        description: "是否上传到 GitHub Release"
        type: boolean
        required: true
        default: false

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    env:
      TEMPLATE_NO_NODE: danmu_api_server.zip
      TEMPLATE_NODE: danmu_api_server_node.zip
      UPSTREAM_SUBDIR: danmu_api
      MANAGER_APP_DIR: manager_app
      MANAGER_APP_APK_PATH: manager_app/app/build/outputs/apk/release/app-release.apk

    steps:
      - name: Checkout current repo
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y zip unzip rsync curl jq binutils zstd xz-utils dpkg

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Build Manager App (APK)
        shell: bash
        run: |
          set -euo pipefail

          VERSION="${{ inputs.module_version }}"
          VERSION_CODE="$(echo "$VERSION" | tr -cd '0-9' | head -c 8)"
          [ -z "$VERSION_CODE" ] && VERSION_CODE=1

          # Ensure required SDK packages
          sdkmanager "platforms;android-34" "build-tools;34.0.0" >/dev/null
          yes | sdkmanager --licenses >/dev/null

          # Patch app version to match module version
          APP_GRADLE="$MANAGER_APP_DIR/app/build.gradle.kts"
          sed -i -E "s/^\s*versionCode\s*=\s*[0-9]+\s*$/    versionCode = ${VERSION_CODE}/" "$APP_GRADLE"
          sed -i -E "s/^\s*versionName\s*=\s*\"[^\"]*\"\s*$/    versionName = \"${VERSION}\"/" "$APP_GRADLE"

          # Build with a downloaded Gradle distribution (no wrapper required)
          GRADLE_VERSION="8.5"
          curl -fL --retry 3 "https://services.gradle.org/distributions/gradle-${GRADLE_VERSION}-bin.zip" -o gradle.zip
          unzip -q gradle.zip -d "$HOME/gradle"

          "$HOME/gradle/gradle-${GRADLE_VERSION}/bin/gradle" -p "$MANAGER_APP_DIR" assembleRelease

          test -f "$MANAGER_APP_APK_PATH"
          ls -l "$MANAGER_APP_APK_PATH"

      - name: Fetch upstream danmu_api
        run: |
          set -euo pipefail
          REPO="${{ inputs.repo_source }}"
          [ "$REPO" = "custom" ] && REPO="${{ inputs.custom_repo }}"
          echo ">>> Cloning $REPO..."
          rm -rf upstream
          git clone --depth 1 "https://github.com/${REPO}.git" upstream
          cd upstream
          git fetch --depth 1 origin "${{ inputs.repo_ref }}" || true
          git checkout -q "${{ inputs.repo_ref }}" 2>/dev/null || git checkout -q FETCH_HEAD
          cd ..

      - name: Build modules
        shell: bash
        run: |
          set -euo pipefail

          VERSION="${{ inputs.module_version }}"
          VERSION_CODE="$(echo "$VERSION" | tr -cd '0-9' | head -c 8)"
          [ -z "$VERSION_CODE" ] && VERSION_CODE=1

          # Resolve selected upstream for core_source.txt
          CORE_REPO="${{ inputs.repo_source }}"
          [ "$CORE_REPO" = "custom" ] && CORE_REPO="${{ inputs.custom_repo }}"
          CORE_REF="${{ inputs.repo_ref }}"

          mkdir -p build/tmp build/out

          # =========================================================
          # Termux helper: fetch a single package (.deb) by name
          # =========================================================
          termux_prepare_index() {
            local arch="aarch64"
            local repo_base="https://packages.termux.dev/apt/termux-main"
            local index_xz="${repo_base}/dists/stable/main/binary-${arch}/Packages.xz"
            local index_plain="${repo_base}/dists/stable/main/binary-${arch}/Packages"

            local work_dir
            work_dir="$(mktemp -d)"
            mkdir -p "$work_dir"

            echo "$repo_base" > "$work_dir/.repo_base"

            if curl -fL --retry 3 "$index_xz" -o "$work_dir/Packages.xz"; then
              xz -dc "$work_dir/Packages.xz" > "$work_dir/Packages"
            else
              curl -fL --retry 3 "$index_plain" -o "$work_dir/Packages"
            fi

            echo "$work_dir"
          }

          termux_pkg_filename() {
            local pkg="$1"
            local pkg_index="$2"
            awk -v pkg="$pkg" '
              BEGIN{RS="";FS="\n"}
              {
                hit=0
                for(i=1;i<=NF;i++){
                  if($i == "Package: " pkg){ hit=1; break }
                }
                if(hit){
                  for(i=1;i<=NF;i++){
                    if(index($i,"Filename: ")==1){
                      sub(/^Filename: /,"",$i);
                      print $i; exit
                    }
                  }
                }
              }' "$pkg_index"
          }

          # =========================================================
          # 下载并提取 Termux Node.js（只拷贝真正需要的 .so 依赖）
          # =========================================================
          fetch_termux_node() {
            local root="$1"
            local arch="aarch64"

            local repo_base="https://packages.termux.dev/apt/termux-main"
            local index_xz="${repo_base}/dists/stable/main/binary-${arch}/Packages.xz"
            local index_plain="${repo_base}/dists/stable/main/binary-${arch}/Packages"

            local work_dir
            work_dir="$(mktemp -d)"
            local extracted="${work_dir}/extracted"
            mkdir -p "$extracted"

            echo "---------------------------------------------------"
            echo ">>> [Node构建] 开始拉取 Termux Node 运行时..."
            echo ">>> [Node构建] Repo: ${repo_base}"

            echo ">>> [Node构建] 下载 Packages 索引..."
            if curl -fL --retry 3 "$index_xz" -o "${work_dir}/Packages.xz"; then
              xz -dc "${work_dir}/Packages.xz" > "${work_dir}/Packages"
            else
              echo ">>> [Node构建] Packages.xz 不可用，回退 Packages..."
              curl -fL --retry 3 "$index_plain" -o "${work_dir}/Packages"
            fi
            local PKG_INDEX="${work_dir}/Packages"

            # 用字符串相等定位 Package 行（避免 libc++ 里的 + 被当正则）
            pkg_filename() {
              local pkg="$1"
              awk -v pkg="$pkg" '
                BEGIN{RS="";FS="\n"}
                {
                  hit=0
                  for(i=1;i<=NF;i++){
                    if($i == "Package: " pkg){ hit=1; break }
                  }
                  if(hit){
                    for(i=1;i<=NF;i++){
                      if(index($i,"Filename: ")==1){
                        sub(/^Filename: /,"",$i);
                        print $i; exit
                      }
                    }
                  }
                }' "$PKG_INDEX"
            }

            pkg_depends() {
              local pkg="$1"
              awk -v pkg="$pkg" '
                BEGIN{RS="";FS="\n"}
                {
                  hit=0
                  for(i=1;i<=NF;i++){
                    if($i == "Package: " pkg){ hit=1; break }
                  }
                  if(hit){
                    for(i=1;i<=NF;i++){
                      if(index($i,"Depends: ")==1){
                        dep=substr($i,10);
                        for(j=i+1;j<=NF && $j ~ /^ /; j++){
                          dep=dep " " substr($j,2);
                        }
                        print dep; exit
                      }
                    }
                  }
                }' "$PKG_INDEX"
            }

            parse_dep_groups() {
              local depstr="${1:-}"
              [ -z "$depstr" ] && return 0
              echo "$depstr" | tr ',' '\n' | while read -r grp; do
                grp="$(echo "$grp" | xargs)"
                [ -z "$grp" ] && continue
                grp="$(echo "$grp" | sed -E 's/\([^)]*\)//g')"
                grp="$(echo "$grp" | sed -E 's/:[a-z0-9_-]+//g')"
                grp="$(echo "$grp" | tr -s ' ' ' ' | xargs)"
                [ -n "$grp" ] && echo "$grp"
              done
            }

            resolve_group() {
              local grp="$1"
              local alt
              IFS='|' read -ra alts <<< "$grp"

              for alt in "${alts[@]}"; do
                alt="$(echo "$alt" | xargs)"
                [ -z "$alt" ] && continue

                local candidates=("$alt")
                if [ "$alt" = "libc++" ]; then
                  candidates=("libc++" "libc++-shared")
                elif [ "$alt" = "libc++-shared" ]; then
                  candidates=("libc++-shared" "libc++")
                fi

                local cand
                for cand in "${candidates[@]}"; do
                  local fname
                  fname="$(pkg_filename "$cand" || true)"
                  if [ -n "$fname" ]; then
                    echo "$cand"
                    return 0
                  fi
                done
              done
              return 1
            }

            download_and_extract() {
              local pkg="$1"
              local fname="$2"
              local url="${repo_base}/${fname}"
              echo ">>> [Node构建] 下载: $pkg"
              curl -fL --retry 3 "$url" -o "${work_dir}/${pkg}.deb"
              dpkg-deb -x "${work_dir}/${pkg}.deb" "$extracted"
              rm -f "${work_dir}/${pkg}.deb"
            }

            # 递归拉取 nodejs 及其依赖包
            declare -A SEEN
            local queue=()
            local node_pkg="nodejs"
            queue+=("$node_pkg")

            while [ "${#queue[@]}" -gt 0 ]; do
              local pkg="${queue[0]}"
              queue=("${queue[@]:1}")

              [ -n "$pkg" ] || continue
              if [ "${SEEN[$pkg]+x}" = "x" ]; then
                continue
              fi
              SEEN["$pkg"]=1

              local fname
              fname="$(pkg_filename "$pkg" || true)"
              if [ -z "$fname" ]; then
                echo "!!! 错误: 在 Packages 索引中找不到包: $pkg"
                exit 1
              fi

              download_and_extract "$pkg" "$fname"

              local deps
              deps="$(pkg_depends "$pkg" || true)"
              while read -r grp; do
                [ -n "$grp" ] || continue
                local resolved
                if ! resolved="$(resolve_group "$grp")"; then
                  echo "!!! 错误: 依赖组无法解析（索引中都不存在）: $grp"
                  exit 1
                fi
                queue+=("$resolved")
              done < <(parse_dep_groups "$deps")
            done

            echo ">>> [Node构建] 定位 node 二进制..."
            local NODE_BIN_PATH
            NODE_BIN_PATH="$(find "$extracted" -type f -path "*/files/usr/bin/node" | head -n 1 || true)"
            if [ -z "$NODE_BIN_PATH" ]; then
              NODE_BIN_PATH="$(find "$extracted" -type f -path "*/usr/bin/node" | head -n 1 || true)"
            fi
            if [ -z "$NODE_BIN_PATH" ]; then
              echo "!!! 错误: 解压后未找到 node 可执行文件"
              exit 1
            fi
            echo "    Found: $NODE_BIN_PATH"

            local PREFIX_DIR
            PREFIX_DIR="$(dirname "$(dirname "$NODE_BIN_PATH")")"
            local LIB_DIR="${PREFIX_DIR}/lib"
            if [ ! -d "$LIB_DIR" ]; then
              echo "!!! 错误: 未找到 lib 目录: $LIB_DIR"
              exit 1
            fi

            echo ">>> [Node构建] 写入模块目录: $root/node/{bin,lib}"
            mkdir -p "$root/node/bin" "$root/node/lib"

            cp -f "$NODE_BIN_PATH" "$root/node/bin/node"
            chmod 0755 "$root/node/bin/node"

            needed_of() {
              local f="$1"
              readelf -d "$f" 2>/dev/null | awk '/NEEDED/{gsub(/\[|\]/,"",$5); print $5}' || true
            }

            find_lib_in_termux() {
              local soname="$1"
              if [ -e "$LIB_DIR/$soname" ] || [ -L "$LIB_DIR/$soname" ]; then
                echo "$LIB_DIR/$soname"
                return 0
              fi
              return 1
            }

            copy_lib_to_module() {
              local src="$1"
              cp -a "$src" "$root/node/lib/"

              if [ -L "$src" ]; then
                local tgt
                tgt="$(readlink -f "$src" || true)"
                if [ -n "$tgt" ] && [ -e "$tgt" ]; then
                  cp -a "$tgt" "$root/node/lib/"
                fi
              fi
            }

            declare -A DONE_LIB
            local file_q=()
            file_q+=("$NODE_BIN_PATH")

            while [ "${#file_q[@]}" -gt 0 ]; do
              local cur="${file_q[0]}"
              file_q=("${file_q[@]:1}")

              for so in $(needed_of "$cur"); do
                if [ "${DONE_LIB[$so]+x}" = "x" ]; then
                  continue
                fi

                local src
                if src="$(find_lib_in_termux "$so")"; then
                  DONE_LIB["$so"]=1
                  copy_lib_to_module "$src"

                  local real_src
                  real_src="$(readlink -f "$src" 2>/dev/null || echo "$src")"
                  if [ -e "$real_src" ]; then
                    file_q+=("$real_src")
                  fi
                else
                  DONE_LIB["$so"]=1
                fi
              done
            done

            strip --strip-unneeded "$root/node/bin/node" 2>/dev/null || true
            find "$root/node/lib" -maxdepth 1 -type f -name "*.so*" -exec strip --strip-unneeded {} \; 2>/dev/null || true

            echo "---------------------------------------------------"
            rm -rf "$work_dir"
          }

          # =========================================================
          # BusyBox: provide inotifyd + wget + unzip on devices without them
          # =========================================================
          fetch_termux_busybox() {
            local root="$1"
            local work_dir
            work_dir="$(termux_prepare_index)"

            local repo_base
            repo_base="$(cat "$work_dir/.repo_base")"
            local pkg_index="$work_dir/Packages"

            local pkg="busybox"
            echo "---------------------------------------------------"
            echo ">>> [BusyBox] 开始拉取 Termux BusyBox..."

            local fname
            fname="$(termux_pkg_filename "$pkg" "$pkg_index" || true)"
            if [ -z "$fname" ]; then
              echo "!!! 错误: 在 Packages 索引中找不到包: $pkg"
              exit 1
            fi

            local url="${repo_base}/${fname}"
            mkdir -p "$work_dir/extracted"

            echo ">>> [BusyBox] 下载: $pkg"
            curl -fL --retry 3 "$url" -o "$work_dir/$pkg.deb"
            dpkg-deb -x "$work_dir/$pkg.deb" "$work_dir/extracted"

            local BB_BIN
            BB_BIN="$(find "$work_dir/extracted" -type f -path "*/files/usr/bin/busybox" | head -n 1 || true)"
            if [ -z "$BB_BIN" ]; then
              BB_BIN="$(find "$work_dir/extracted" -type f -path "*/usr/bin/busybox" | head -n 1 || true)"
            fi
            if [ -z "$BB_BIN" ]; then
              echo "!!! 错误: 解压后未找到 busybox 可执行文件"
              exit 1
            fi

            mkdir -p "$root/bin"
            cp -f "$BB_BIN" "$root/bin/busybox"
            chmod 0755 "$root/bin/busybox"

            # Optional: strip for size
            strip --strip-unneeded "$root/bin/busybox" 2>/dev/null || true

            echo ">>> [BusyBox] 写入: $root/bin/busybox"
            rm -rf "$work_dir"
            echo "---------------------------------------------------"
          }

          finalize_zip() {
            local root="$1"
            local out_name="$2"
            echo ">>> 打包: $out_name"
            find "$root" -type f -name "*.sh" -exec chmod 0755 {} \;
            [ -f "$root/bin/busybox" ] && chmod 0755 "$root/bin/busybox" || true
            (cd "$root" && zip -r "../../out/${out_name}" .)
          }

          # Path to built Manager APK
          MANAGER_APK="$MANAGER_APP_APK_PATH"
          if [ ! -f "$MANAGER_APK" ]; then
            echo "!!! 错误: 未找到 Manager APK: $MANAGER_APK"
            exit 1
          fi

          if [[ "${{ inputs.build_variant }}" == "both" || "${{ inputs.build_variant }}" == "no_node" ]]; then
            echo ">>> [TASK] 构建 No-Node 版本..."
            unzip -q "${TEMPLATE_NO_NODE}" -d build/tmp/no_node
            MODULE_ROOT=$(find build/tmp/no_node -name "module.prop" | head -n 1 | xargs dirname)

            mkdir -p "$MODULE_ROOT/app/danmu_api"
            rsync -a --delete "upstream/${UPSTREAM_SUBDIR}/" "$MODULE_ROOT/app/danmu_api/"

            # Core source info for seeding persistent core
            mkdir -p "$MODULE_ROOT/defaults"
            {
              echo "repo=${CORE_REPO}"
              echo "ref=${CORE_REF}"
              echo "built_at=$(date '+%F %T')"
            } > "$MODULE_ROOT/defaults/core_source.txt"

            # Manager App (systemless)
            mkdir -p "$MODULE_ROOT/system/app/DanmuApiManager"
            cp -f "$MANAGER_APK" "$MODULE_ROOT/system/app/DanmuApiManager/DanmuApiManager.apk"

            # Always ship BusyBox helpers
            fetch_termux_busybox "$MODULE_ROOT"

            sed -i "s|^version=.*|version=${VERSION}|g" "$MODULE_ROOT/module.prop"
            sed -i "s|^versionCode=.*|versionCode=${VERSION_CODE}|g" "$MODULE_ROOT/module.prop"

            finalize_zip "$MODULE_ROOT" "danmu_api_server_${VERSION}.zip"
          fi

          if [[ "${{ inputs.build_variant }}" == "both" || "${{ inputs.build_variant }}" == "node" ]]; then
            echo ">>> [TASK] 构建 Node 完整版..."
            unzip -q "${TEMPLATE_NODE}" -d build/tmp/node
            MODULE_ROOT=$(find build/tmp/node -name "module.prop" | head -n 1 | xargs dirname)

            mkdir -p "$MODULE_ROOT/app/danmu_api"
            rsync -a --delete "upstream/${UPSTREAM_SUBDIR}/" "$MODULE_ROOT/app/danmu_api/"

            # Core source info for seeding persistent core
            mkdir -p "$MODULE_ROOT/defaults"
            {
              echo "repo=${CORE_REPO}"
              echo "ref=${CORE_REF}"
              echo "built_at=$(date '+%F %T')"
            } > "$MODULE_ROOT/defaults/core_source.txt"

            # Manager App (systemless)
            mkdir -p "$MODULE_ROOT/system/app/DanmuApiManager"
            cp -f "$MANAGER_APK" "$MODULE_ROOT/system/app/DanmuApiManager/DanmuApiManager.apk"

            # Always ship BusyBox helpers
            fetch_termux_busybox "$MODULE_ROOT"

            # Ship Node runtime
            fetch_termux_node "$MODULE_ROOT"

            sed -i "s|^version=.*|version=${VERSION}|g" "$MODULE_ROOT/module.prop"
            sed -i "s|^versionCode=.*|versionCode=${VERSION_CODE}|g" "$MODULE_ROOT/module.prop"

            finalize_zip "$MODULE_ROOT" "danmu_api_server_node_${VERSION}.zip"
          fi

      - name: Upload Flashable Modules
        uses: actions/upload-artifact@v4
        with:
          name: Danmu_API_v${{ inputs.module_version }}
          path: build/out/*.zip

      - name: Create Release
        if: ${{ inputs.publish_release }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ inputs.module_version }}
          files: build/out/*.zip
          generate_release_notes: true
