name: Build Danmu API Magisk Modules

on:
  workflow_dispatch:
    inputs:
      repo_source:
        description: "选择 danmu_api 源仓库"
        type: choice
        options:
          - huangxd-/danmu_api
          - lilixu3/danmu_api
          - custom
        default: huangxd-/danmu_api
        required: true

      custom_repo:
        description: "自定义仓库（owner/repo）"
        type: string
        required: false
        default: ""

      repo_ref:
        description: "分支 / Tag / Commit"
        type: string
        required: true
        default: main

      build_variant:
        description: "构建版本"
        type: choice
        options:
          - both
          - no_node
          - node
        default: both
        required: true

      module_version:
        description: "模块版本号"
        type: string
        required: true
        default: "1.1.2"

      publish_release:
        description: "是否上传到 GitHub Release"
        type: boolean
        required: true
        default: false

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    env:
      TEMPLATE_NO_NODE: danmu_api_server.zip
      TEMPLATE_NODE: danmu_api_server_node.zip
      UPSTREAM_SUBDIR: danmu_api

    steps:
      - name: Checkout current repo
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y zip unzip rsync curl jq binutils zstd xz-utils dpkg

      - name: Fetch upstream danmu_api
        run: |
          set -euo pipefail
          REPO="${{ inputs.repo_source }}"
          [ "$REPO" = "custom" ] && REPO="${{ inputs.custom_repo }}"
          echo ">>> Cloning $REPO..."
          rm -rf upstream
          git clone --depth 1 "https://github.com/${REPO}.git" upstream
          cd upstream
          # 支持 branch / tag / commit
          git fetch --depth 1 origin "${{ inputs.repo_ref }}" || true
          git checkout -q "${{ inputs.repo_ref }}" 2>/dev/null || git checkout -q FETCH_HEAD
          cd ..

      - name: Build modules
        run: |
          set -euo pipefail
          VERSION="${{ inputs.module_version }}"
          VERSION_CODE="$(echo "$VERSION" | tr -cd '0-9' | head -c 8)"
          [ -z "$VERSION_CODE" ] && VERSION_CODE=1

          mkdir -p build/tmp build/out

          # =========================================================
          # 函数：下载并提取 Termux Node.js（递归解析 Depends，支持 | 备选 & libc++ 映射）
          # =========================================================
          fetch_termux_node() {
            local root="$1"
            local arch="aarch64"

            # Termux 主仓库（你原始写法的域名）
            local repo_base="https://packages.termux.dev/apt/termux-main"
            local index_xz="${repo_base}/dists/stable/main/binary-${arch}/Packages.xz"
            local index_plain="${repo_base}/dists/stable/main/binary-${arch}/Packages"

            local work_dir
            work_dir="$(mktemp -d)"
            local extracted="${work_dir}/extracted"
            mkdir -p "$extracted"

            echo "---------------------------------------------------"
            echo ">>> [Node构建] 开始拉取 Termux Node 运行时..."
            echo ">>> [Node构建] Repo: ${repo_base}"

            # 下载索引（优先 xz，失败则回退 plain）
            echo ">>> [Node构建] 下载 Packages 索引..."
            if curl -fL --retry 3 "$index_xz" -o "${work_dir}/Packages.xz"; then
              xz -dc "${work_dir}/Packages.xz" > "${work_dir}/Packages"
            else
              echo ">>> [Node构建] Packages.xz 不可用，回退 Packages..."
              curl -fL --retry 3 "$index_plain" -o "${work_dir}/Packages"
            fi
            local PKG_INDEX="${work_dir}/Packages"

            # 查包 Filename
            pkg_filename() {
              local pkg="$1"
              awk -v pkg="$pkg" '
                BEGIN{RS="";FS="\n"}
                $0 ~ "(^|\n)Package: " pkg "(\n|$)" {
                  for(i=1;i<=NF;i++){
                    if($i ~ /^Filename: /){
                      sub(/^Filename: /,"",$i);
                      print $i; exit
                    }
                  }
                }' "$PKG_INDEX"
            }

            # 查包 Depends（合并折行）
            pkg_depends() {
              local pkg="$1"
              awk -v pkg="$pkg" '
                BEGIN{RS="";FS="\n"}
                $0 ~ "(^|\n)Package: " pkg "(\n|$)" {
                  for(i=1;i<=NF;i++){
                    if($i ~ /^Depends: /){
                      dep=substr($i,10);
                      for(j=i+1;j<=NF && $j ~ /^ /; j++){
                        dep=dep " " substr($j,2);
                      }
                      print dep; exit
                    }
                  }
                }' "$PKG_INDEX"
            }

            # 解析 Depends => 依赖“组”(逗号分隔)，每组内部可用 | 表示备选
            # - 去掉版本约束 (>= x)
            # - 去掉 :any / :all / :aarch64 等
            parse_dep_groups() {
              local depstr="${1:-}"
              [ -z "$depstr" ] && return 0
              echo "$depstr" | tr ',' '\n' | while read -r grp; do
                grp="$(echo "$grp" | xargs)"
                [ -z "$grp" ] && continue
                # 去版本约束
                grp="$(echo "$grp" | sed -E 's/\([^)]*\)//g')"
                # 去掉架构修饰（对组内每个备选都做一次）
                grp="$(echo "$grp" | sed -E 's/:[a-z0-9_-]+//g')"
                grp="$(echo "$grp" | tr -s ' ' ' ' | xargs)"
                [ -n "$grp" ] && echo "$grp"
              done
            }

            # 选择依赖组内第一个“在索引中存在”的备选
            # 特殊映射：libc++ => libc++-shared（一些仓库里没有 libc++ 这个实体包）
            resolve_group() {
              local grp="$1"
              local alt
              IFS='|' read -ra alts <<< "$grp"
              for alt in "${alts[@]}"; do
                alt="$(echo "$alt" | xargs)"
                [ -z "$alt" ] && continue
                if [ "$alt" = "libc++" ]; then
                  alt="libc++-shared"
                fi
                local fname
                fname="$(pkg_filename "$alt" || true)"
                if [ -n "$fname" ]; then
                  echo "$alt"
                  return 0
                fi
              done
              return 1
            }

            # 下载并解压（dpkg-deb 自动处理 data.tar.* 的压缩）
            download_and_extract() {
              local pkg="$1"
              local fname="$2"
              local url="${repo_base}/${fname}"
              echo ">>> [Node构建] 下载: $pkg"
              curl -fL --retry 3 "$url" -o "${work_dir}/${pkg}.deb"
              dpkg-deb -x "${work_dir}/${pkg}.deb" "$extracted"
              rm -f "${work_dir}/${pkg}.deb"
            }

            # BFS 递归拉取依赖
            declare -A SEEN
            local queue=()
            local node_pkg="nodejs"   # 需要 LTS 可改：nodejs-lts
            queue+=("$node_pkg")

            while [ "${#queue[@]}" -gt 0 ]; do
              local pkg="${queue[0]}"
              queue=("${queue[@]:1}")

              [ -n "$pkg" ] || continue
              if [ "${SEEN[$pkg]+x}" = "x" ]; then
                continue
              fi
              SEEN["$pkg"]=1

              local fname
              fname="$(pkg_filename "$pkg" || true)"
              if [ -z "$fname" ]; then
                echo "!!! 错误: 在 Packages 索引中找不到包: $pkg"
                exit 1
              fi

              download_and_extract "$pkg" "$fname"

              local deps
              deps="$(pkg_depends "$pkg" || true)"
              while read -r grp; do
                [ -n "$grp" ] || continue
                local resolved
                if ! resolved="$(resolve_group "$grp")"; then
                  echo "!!! 错误: 依赖组无法解析（索引中都不存在）: $grp"
                  exit 1
                fi
                # resolved 可能已被映射（如 libc++ -> libc++-shared）
                queue+=("$resolved")
              done < <(parse_dep_groups "$deps")
            done

            echo ">>> [Node构建] 定位 node 二进制..."
            local NODE_BIN_PATH
            NODE_BIN_PATH="$(find "$extracted" -type f -path "*/files/usr/bin/node" | head -n 1 || true)"
            if [ -z "$NODE_BIN_PATH" ]; then
              NODE_BIN_PATH="$(find "$extracted" -type f -path "*/usr/bin/node" | head -n 1 || true)"
            fi
            if [ -z "$NODE_BIN_PATH" ]; then
              echo "!!! 错误: 解压后未找到 node 可执行文件"
              echo ">>> 调试：列出可能的 bin 目录"
              find "$extracted" -maxdepth 8 -type d -name bin -print || true
              exit 1
            fi
            echo "    Found: $NODE_BIN_PATH"

            local PREFIX_DIR
            PREFIX_DIR="$(dirname "$(dirname "$NODE_BIN_PATH")")"  # .../usr
            local LIB_DIR="${PREFIX_DIR}/lib"
            if [ ! -d "$LIB_DIR" ]; then
              echo "!!! 错误: 未找到 lib 目录: $LIB_DIR"
              exit 1
            fi

            echo ">>> [Node构建] 写入模块目录: $root/node/{bin,lib}"
            mkdir -p "$root/node/bin" "$root/node/lib"

            cp -f "$NODE_BIN_PATH" "$root/node/bin/node"
            chmod 0755 "$root/node/bin/node"

            # 保留软链接（很关键）
            cp -a "$LIB_DIR"/. "$root/node/lib/"

            # 强校验：避免出现“目录空但继续打包”
            if [ ! -s "$root/node/bin/node" ]; then
              echo "!!! 错误: node 写入失败（文件为空或不存在）"
              exit 1
            fi
            local lib_items
            lib_items="$(find "$root/node/lib" -mindepth 1 \( -type f -o -type l -o -type d \) | wc -l | tr -d ' ')"
            if [ "${lib_items:-0}" -eq 0 ]; then
              echo "!!! 错误: node/lib 仍为空（依赖未写入）"
              exit 1
            fi

            echo ">>> [Node构建] 注入 service.sh 环境变量（可靠插入，保留 shebang）..."
            if [ -f "$root/service.sh" ]; then
              if ! grep -q "### NODE ENV BEGIN" "$root/service.sh"; then
                local snip="${work_dir}/node_env_snip"
                cat >"$snip"<<'EOF'
### NODE ENV BEGIN
MODDIR=${0%/*}
export PATH="$MODDIR/node/bin:$PATH"
export LD_LIBRARY_PATH="$MODDIR/node/lib:${LD_LIBRARY_PATH:-}"
### NODE ENV END
EOF
                local tmp="${work_dir}/service.sh.tmp"
                head -n 1 "$root/service.sh" > "$tmp"
                cat "$snip" >> "$tmp"
                tail -n +2 "$root/service.sh" >> "$tmp"
                mv "$tmp" "$root/service.sh"
                chmod 0755 "$root/service.sh"
              fi
            fi

            echo ">>> [Node构建] 验证通过:"
            echo "    node/bin/node: $(ls -l "$root/node/bin/node")"
            echo "    node/lib items: $lib_items"
            echo "    libc++_shared.so exists? $( [ -e "$root/node/lib/libc++_shared.so" ] && echo yes || echo no )"
            echo "---------------------------------------------------"

            rm -rf "$work_dir"
          }

          # =========================================================
          # 函数：打包 ZIP
          # =========================================================
          finalize_zip() {
            local root="$1"
            local out_name="$2"
            echo ">>> 打包: $out_name"
            find "$root" -type f -name "*.sh" -exec chmod 0755 {} \;
            (cd "$root" && zip -r "../../out/${out_name}" .)
          }

          # =========================================================
          # 流程 1: No-Node 版本
          # =========================================================
          if [[ "${{ inputs.build_variant }}" == "both" || "${{ inputs.build_variant }}" == "no_node" ]]; then
            echo ">>> [TASK] 构建 No-Node 版本..."
            unzip -q "${TEMPLATE_NO_NODE}" -d build/tmp/no_node

            MODULE_ROOT=$(find build/tmp/no_node -name "module.prop" | head -n 1 | xargs dirname)

            mkdir -p "$MODULE_ROOT/app/danmu_api"
            rsync -a --delete "upstream/${UPSTREAM_SUBDIR}/" "$MODULE_ROOT/app/danmu_api/"

            sed -i "s|^version=.*|version=${VERSION}|g" "$MODULE_ROOT/module.prop"
            sed -i "s|^versionCode=.*|versionCode=${VERSION_CODE}|g" "$MODULE_ROOT/module.prop"

            finalize_zip "$MODULE_ROOT" "danmu_api_server_${VERSION}.zip"
          fi

          # =========================================================
          # 流程 2: Node 版本
          # =========================================================
          if [[ "${{ inputs.build_variant }}" == "both" || "${{ inputs.build_variant }}" == "node" ]]; then
            echo ">>> [TASK] 构建 Node 完整版..."
            unzip -q "${TEMPLATE_NODE}" -d build/tmp/node

            MODULE_ROOT=$(find build/tmp/node -name "module.prop" | head -n 1 | xargs dirname)

            mkdir -p "$MODULE_ROOT/app/danmu_api"
            rsync -a --delete "upstream/${UPSTREAM_SUBDIR}/" "$MODULE_ROOT/app/danmu_api/"

            fetch_termux_node "$MODULE_ROOT"

            sed -i "s|^version=.*|version=${VERSION}|g" "$MODULE_ROOT/module.prop"
            sed -i "s|^versionCode=.*|versionCode=${VERSION_CODE}|g" "$MODULE_ROOT/module.prop"

            finalize_zip "$MODULE_ROOT" "danmu_api_server_node_${VERSION}.zip"
          fi

      - name: Upload Flashable Modules
        uses: actions/upload-artifact@v4
        with:
          name: Danmu_API_v${{ inputs.module_version }}
          path: build/out/*.zip

      - name: Create Release
        if: ${{ inputs.publish_release }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ inputs.module_version }}
          files: build/out/*.zip
          generate_release_notes: true
