name: Build Danmu API Magisk Modules

on:
  workflow_dispatch:
    inputs:
      repo_source:
        description: "选择 danmu_api 源仓库"
        type: choice
        options:
          - huangxd-/danmu_api
          - lilixu3/danmu_api
          - custom
        default: huangxd-/danmu_api
        required: true

      custom_repo:
        description: "自定义仓库（owner/repo）"
        type: string
        required: false
        default: ""

      repo_ref:
        description: "分支 / Tag / Commit"
        type: string
        required: true
        default: main

      build_variant:
        description: "构建版本"
        type: choice
        options:
          - both
          - no_node
          - node
        default: both
        required: true

      module_version:
        description: "模块版本号"
        type: string
        required: true
        default: "1.1.2"

      publish_release:
        description: "是否上传到 GitHub Release"
        type: boolean
        required: true
        default: false

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    env:
      TEMPLATE_NO_NODE: danmu_api_server.zip
      TEMPLATE_NODE: danmu_api_server_node.zip
      UPSTREAM_SUBDIR: danmu_api

    steps:
      - name: Checkout current repo
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y zip unzip rsync curl jq binutils zstd xz-utils dpkg

      - name: Fetch upstream danmu_api
        run: |
          set -euo pipefail
          REPO="${{ inputs.repo_source }}"
          [ "$REPO" = "custom" ] && REPO="${{ inputs.custom_repo }}"
          echo ">>> Cloning $REPO..."
          rm -rf upstream
          git clone --depth 1 "https://github.com/${REPO}.git" upstream
          cd upstream
          # 支持 branch / tag / commit
          git fetch --depth 1 origin "${{ inputs.repo_ref }}" || true
          git checkout -q "${{ inputs.repo_ref }}" 2>/dev/null || git checkout -q FETCH_HEAD
          cd ..

      - name: Build modules
        run: |
          set -euo pipefail
          VERSION="${{ inputs.module_version }}"
          VERSION_CODE="$(echo "$VERSION" | tr -cd '0-9' | head -c 8)"
          [ -z "$VERSION_CODE" ] && VERSION_CODE=1

          mkdir -p build/tmp build/out

          # =========================================================
          # 函数：下载并提取 Termux Node.js（递归解析 Depends，确保 node/bin 与 node/lib 非空）
          # =========================================================
          fetch_termux_node() {
            local root="$1"
            local arch="aarch64"

            # 使用 termux.net 的 stable 仓库（有 Packages.xz，体积小，稳定）
            local repo_base="https://termux.net"
            local pkg_index_url="${repo_base}/dists/stable/main/binary-${arch}/Packages.xz"

            local work_dir
            work_dir="$(mktemp -d)"
            local extracted="${work_dir}/extracted"
            mkdir -p "$extracted"

            echo "---------------------------------------------------"
            echo ">>> [Node构建] 开始拉取 Termux Node 运行时..."
            echo ">>> [Node构建] Repo: ${repo_base}"
            echo ">>> [Node构建] Index: ${pkg_index_url}"

            echo ">>> [Node构建] 下载 Packages.xz..."
            curl -fL --retry 3 "$pkg_index_url" -o "${work_dir}/Packages.xz"
            xz -dc "${work_dir}/Packages.xz" > "${work_dir}/Packages"

            local PKG_INDEX="${work_dir}/Packages"

            # 取某个包的 Filename
            pkg_filename() {
              local pkg="$1"
              awk -v pkg="$pkg" '
                BEGIN{RS="";FS="\n"}
                $0 ~ "(^|\n)Package: " pkg "(\n|$)" {
                  for(i=1;i<=NF;i++){
                    if($i ~ /^Filename: /){
                      sub(/^Filename: /,"",$i);
                      print $i; exit
                    }
                  }
                }' "$PKG_INDEX"
            }

            # 取某个包的 Depends（合并折行）
            pkg_depends() {
              local pkg="$1"
              awk -v pkg="$pkg" '
                BEGIN{RS="";FS="\n"}
                $0 ~ "(^|\n)Package: " pkg "(\n|$)" {
                  for(i=1;i<=NF;i++){
                    if($i ~ /^Depends: /){
                      dep=substr($i,10);
                      for(j=i+1;j<=NF && $j ~ /^ /; j++){
                        dep=dep " " substr($j,2);
                      }
                      print dep; exit
                    }
                  }
                }' "$PKG_INDEX"
            }

            # 解析 Depends 字符串 -> 依赖包名列表（取第一个备选，去版本/架构修饰）
            parse_depends() {
              local depstr="$1"
              depstr="${depstr:-}"
              [ -z "$depstr" ] && return 0

              # 逗号分隔
              echo "$depstr" | tr ',' '\n' | while read -r item; do
                item="$(echo "$item" | xargs)"
                [ -z "$item" ] && continue

                # 取第一个备选（foo | bar）
                item="$(echo "$item" | awk -F'|' '{print $1}')"
                item="$(echo "$item" | xargs)"

                # 去掉版本约束 (>= x)
                item="$(echo "$item" | sed -E 's/\([^)]*\)//g')"
                item="$(echo "$item" | xargs)"

                # 去掉 :any / :all / :aarch64 等
                item="$(echo "$item" | sed -E 's/:[a-z0-9_-]+//g')"
                item="$(echo "$item" | xargs)"

                # 过滤空
                [ -n "$item" ] && echo "$item"
              done
            }

            # 下载并解压 .deb（用 dpkg-deb 自动处理 xz/zst/gz）
            download_and_extract() {
              local pkg="$1"
              local fname="$2"
              local url="${repo_base}/${fname}"

              echo ">>> [Node构建] 下载: $pkg"
              curl -fL --retry 3 "$url" -o "${work_dir}/${pkg}.deb"
              dpkg-deb -x "${work_dir}/${pkg}.deb" "$extracted"
              rm -f "${work_dir}/${pkg}.deb"
            }

            # 递归解析依赖并解压
            declare -A SEEN
            local queue=()
            local node_pkg="nodejs"   # 需要 LTS 可改为 nodejs-lts
            queue+=("$node_pkg")

            while [ "${#queue[@]}" -gt 0 ]; do
              local pkg="${queue[0]}"
              queue=("${queue[@]:1}")

              [ -n "$pkg" ] || continue
              if [ "${SEEN[$pkg]+x}" = "x" ]; then
                continue
              fi
              SEEN["$pkg"]=1

              local fname
              fname="$(pkg_filename "$pkg" || true)"
              if [ -z "$fname" ]; then
                echo "!!! 错误: 在 Packages 索引中找不到包: $pkg"
                exit 1
              fi

              download_and_extract "$pkg" "$fname"

              local deps
              deps="$(pkg_depends "$pkg" || true)"
              while read -r dep; do
                [ -n "$dep" ] && queue+=("$dep")
              done < <(parse_depends "$deps")
            done

            echo ">>> [Node构建] 定位 node 二进制..."
            local NODE_BIN_PATH
            NODE_BIN_PATH="$(find "$extracted" -type f -path "*/files/usr/bin/node" | head -n 1 || true)"
            if [ -z "$NODE_BIN_PATH" ]; then
              # 兼容极少数包名/路径变化
              NODE_BIN_PATH="$(find "$extracted" -type f -path "*/usr/bin/node" | head -n 1 || true)"
            fi
            if [ -z "$NODE_BIN_PATH" ]; then
              echo "!!! 错误: 解压后未找到 node 可执行文件"
              echo ">>> 调试：列出可能的 bin 目录"
              find "$extracted" -maxdepth 6 -type d -name bin -print || true
              exit 1
            fi
            echo "    Found: $NODE_BIN_PATH"

            local PREFIX_DIR
            PREFIX_DIR="$(dirname "$(dirname "$NODE_BIN_PATH")")"  # .../usr
            local LIB_DIR="${PREFIX_DIR}/lib"
            if [ ! -d "$LIB_DIR" ]; then
              echo "!!! 错误: 未找到 lib 目录: $LIB_DIR"
              exit 1
            fi

            echo ">>> [Node构建] 写入模块目录: $root/node/{bin,lib}"
            mkdir -p "$root/node/bin" "$root/node/lib"

            # node
            cp -f "$NODE_BIN_PATH" "$root/node/bin/node"
            chmod 0755 "$root/node/bin/node"

            # libs（包含 node_modules 等）
            cp -a "$LIB_DIR"/. "$root/node/lib/"

            # 强校验：避免出现“node/bin、node/lib 空目录但构建仍通过”
            if [ ! -s "$root/node/bin/node" ]; then
              echo "!!! 错误: node 写入失败（文件为空或不存在）"
              exit 1
            fi

            local lib_items
            lib_items="$(find "$root/node/lib" -mindepth 1 \( -type f -o -type l -o -type d \) | wc -l | tr -d ' ')"
            if [ "${lib_items:-0}" -eq 0 ]; then
              echo "!!! 错误: node/lib 仍为空（依赖未写入）"
              exit 1
            fi

            echo ">>> [Node构建] 验证通过:"
            echo "    node/bin: $(ls -al "$root/node/bin" | wc -l) lines"
            echo "    node/lib items: $lib_items"
            echo "    libc++_shared.so exists? $( [ -e "$root/node/lib/libc++_shared.so" ] && echo yes || echo no )"
            echo "---------------------------------------------------"

            rm -rf "$work_dir"
          }

          # =========================================================
          # 函数：打包 ZIP
          # =========================================================
          finalize_zip() {
            local root="$1"
            local out_name="$2"
            echo ">>> 打包: $out_name"
            find "$root" -type f -name "*.sh" -exec chmod 0755 {} \;
            (cd "$root" && zip -r "../../out/${out_name}" .)
          }

          # =========================================================
          # 流程 1: No-Node 版本
          # =========================================================
          if [[ "${{ inputs.build_variant }}" == "both" || "${{ inputs.build_variant }}" == "no_node" ]]; then
            echo ">>> [TASK] 构建 No-Node 版本..."
            unzip -q "${TEMPLATE_NO_NODE}" -d build/tmp/no_node

            MODULE_ROOT=$(find build/tmp/no_node -name "module.prop" | head -n 1 | xargs dirname)

            mkdir -p "$MODULE_ROOT/app/danmu_api"
            rsync -a --delete "upstream/${UPSTREAM_SUBDIR}/" "$MODULE_ROOT/app/danmu_api/"

            sed -i "s|^version=.*|version=${VERSION}|g" "$MODULE_ROOT/module.prop"
            sed -i "s|^versionCode=.*|versionCode=${VERSION_CODE}|g" "$MODULE_ROOT/module.prop"

            finalize_zip "$MODULE_ROOT" "danmu_api_server_${VERSION}.zip"
          fi

          # =========================================================
          # 流程 2: Node 版本
          # =========================================================
          if [[ "${{ inputs.build_variant }}" == "both" || "${{ inputs.build_variant }}" == "node" ]]; then
            echo ">>> [TASK] 构建 Node 完整版..."
            unzip -q "${TEMPLATE_NODE}" -d build/tmp/node

            MODULE_ROOT=$(find build/tmp/node -name "module.prop" | head -n 1 | xargs dirname)

            mkdir -p "$MODULE_ROOT/app/danmu_api"
            rsync -a --delete "upstream/${UPSTREAM_SUBDIR}/" "$MODULE_ROOT/app/danmu_api/"

            # 下载并注入 Node（确保 node/bin 与 node/lib 不为空，否则直接失败）
            fetch_termux_node "$MODULE_ROOT"

            sed -i "s|^version=.*|version=${VERSION}|g" "$MODULE_ROOT/module.prop"
            sed -i "s|^versionCode=.*|versionCode=${VERSION_CODE}|g" "$MODULE_ROOT/module.prop"

            finalize_zip "$MODULE_ROOT" "danmu_api_server_node_${VERSION}.zip"
          fi

      - name: Upload Flashable Modules
        uses: actions/upload-artifact@v4
        with:
          name: Danmu_API_v${{ inputs.module_version }}
          path: build/out/*.zip

      - name: Create Release
        if: ${{ inputs.publish_release }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ inputs.module_version }}
          files: build/out/*.zip
          generate_release_notes: true
