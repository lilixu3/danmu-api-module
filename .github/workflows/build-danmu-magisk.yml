name: Build Danmu API Magisk Modules

on:
  workflow_dispatch:
    inputs:
      repo_source:
        description: "选择 danmu_api 源仓库"
        type: choice
        options:
          - huangxd-/danmu_api
          - lilixu3/danmu_api
          - custom
        default: huangxd-/danmu_api
        required: true

      custom_repo:
        description: "自定义仓库（owner/repo），当 repo_source=custom 时生效"
        type: string
        required: false
        default: ""

      repo_ref:
        description: "分支 / Tag / Commit（默认 main）"
        type: string
        required: true
        default: main

      build_variant:
        description: "构建版本"
        type: choice
        options:
          - both
          - no_node
          - node
        default: both
        required: true

      module_version:
        description: "模块版本号"
        type: string
        required: true
        default: "1.1.2"

      publish_release:
        description: "是否上传到 GitHub Release"
        type: boolean
        required: true
        default: false

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    env:
      TEMPLATE_NO_NODE: danmu_api_server.zip
      TEMPLATE_NODE: danmu_api_server_node.zip
      UPSTREAM_SUBDIR: danmu_api

    steps:
      - name: Checkout current repo
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y zip unzip rsync curl jq binutils zstd

      - name: Fetch upstream danmu_api
        run: |
          REPO="${{ inputs.repo_source }}"
          [ "$REPO" = "custom" ] && REPO="${{ inputs.custom_repo }}"
          git clone --depth 1 --branch "${{ inputs.repo_ref }}" "https://github.com/${REPO}.git" upstream

      - name: Build modules
        run: |
          set -euo pipefail
          VERSION="${{ inputs.module_version }}"
          VERSION_CODE="$(echo "$VERSION" | tr -cd '0-9' | head -c 8)"
          mkdir -p build/tmp build/out

          # --- 函数：下载并提取 Termux Node.js ---
          fetch_termux_node() {
            local root="$1"
            echo "正在从 Termux 仓库获取最新 Node.js (aarch64)..."
            
            local repo_url="https://packages.termux.dev/apt/termux-main"
            # 这里的解析逻辑更健壮一点
            local deb_path=$(curl -sL "${repo_url}/dists/stable/main/binary-aarch64/Packages" | grep -A 20 "Package: nodejs$" | grep "Filename:" | awk '{print $2}' | head -n 1)
            
            if [ -z "$deb_path" ]; then
              echo "无法获取 Termux Node.js 下载地址"
              exit 1
            fi

            curl -L -o node.deb "${repo_url}/${deb_path}"
            
            # 提取 deb 内部文件
            ar x node.deb
            
            # 找到数据包（可能是 .xz 或 .zst）
            local data_tar=$(ls data.tar.* | head -n 1)
            echo "正在解压 $data_tar ..."
            
            if [[ "$data_tar" == *.zst ]]; then
                tar --zstd -xf "$data_tar"
            else
                tar -xf "$data_tar"
            fi
            
            # --- 核心修复：使用 find 动态定位文件 ---
            # 寻找 node 二进制文件
            local bin_src=$(find . -type f -name "node" | grep "/bin/node" | head -n 1)
            if [ -z "$bin_src" ]; then
                echo "错误：未能在包内找到 node 二进制文件"
                exit 1
            fi
            mkdir -p "$root/node/bin"
            cp "$bin_src" "$root/node/bin/"
            chmod 0755 "$root/node/bin/node"
            
            # 寻找所有的 .so 依赖库
            mkdir -p "$root/lib"
            # 提取 usr/lib 目录下的所有库文件，保留软连接 (-d)
            find . -path "*/usr/lib/*.so*" -type f -o -type l | while read -r lib_file; do
                cp -d "$lib_file" "$root/lib/"
            done
            
            echo "Node.js 及依赖库提取完成"
          }

          # --- 函数：打包 ---
          finalize_zip() {
            local root="$1"
            local out_name="$2"
            # 修复权限
            find "$root" -type f -name "*.sh" -exec chmod 0755 {} \;
            # 确保 zip 内部没有多余的一层文件夹（cd 到 root 内部再压）
            (cd "$root" && zip -r "../../out/${out_name}" .)
          }

          # 1. 构建 No-Node 版本
          if [[ "${{ inputs.build_variant }}" == "both" || "${{ inputs.build_variant }}" == "no_node" ]]; then
            unzip -q "${TEMPLATE_NO_NODE}" -d build/tmp/no_node
            MODULE_ROOT=$(find build/tmp/no_node -name "module.prop" -exec dirname {} | head -n 1)
            rsync -a --delete "upstream/${UPSTREAM_SUBDIR}/" "$MODULE_ROOT/app/danmu_api/"
            sed -i "s|^version=.*|version=${VERSION}|g" "$MODULE_ROOT/module.prop"
            sed -i "s|^versionCode=.*|versionCode=${VERSION_CODE}|g" "$MODULE_ROOT/module.prop"
            finalize_zip "$MODULE_ROOT" "danmu_api_server_${VERSION}.zip"
          fi

          # 2. 构建 Node 版本
          if [[ "${{ inputs.build_variant }}" == "both" || "${{ inputs.build_variant }}" == "node" ]]; then
            unzip -q "${TEMPLATE_NODE}" -d build/tmp/node
            MODULE_ROOT=$(find build/tmp/node -name "module.prop" -exec dirname {} | head -n 1)
            rsync -a --delete "upstream/${UPSTREAM_SUBDIR}/" "$MODULE_ROOT/app/danmu_api/"
            
            # 提取 Node
            fetch_termux_node "$MODULE_ROOT"
            
            sed -i "s|^version=.*|version=${VERSION}|g" "$MODULE_ROOT/module.prop"
            sed -i "s|^versionCode=.*|versionCode=${VERSION_CODE}|g" "$MODULE_ROOT/module.prop"
            finalize_zip "$MODULE_ROOT" "danmu_api_server_node_${VERSION}.zip"
          fi

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Danmu_API_Flashable_v${{ inputs.module_version }}
          path: build/out/*.zip

      - name: Create Release
        if: ${{ inputs.publish_release }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ inputs.module_version }}
          files: build/out/*.zip
          generate_release_notes: true
